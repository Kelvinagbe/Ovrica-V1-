const C=require('./0x744.json');class K{constructor(o,h){this.o=o;this.h=h;this.l=C.x2a;this.p=C.x3b}async g(n){const c=this.h.g(n,this.p);if(c){console.log(`${C.x4e} Key '${n}' cached`);return c}try{const d=await this.o.v(),l=d.collection(this.l),r=await l.findOne({name:n});if(r&&r.value){this.h.s(n,r.value,this.p);console.log(`${C.x4a} Key '${n}' fetched`);return r.value}console.warn(`${C.x4d} Key '${n}' not found`);return null}catch(e){console.error(`${C.x4c} Get key '${n}':`,e.message);throw e}}async s(n,v,desc=''){try{const d=await this.o.v(),l=d.collection(this.l);await l.updateOne({name:n},{$set:{name:n,value:v,description:desc,updatedAt:new Date()}},{upsert:!0});this.h.s(n,v,this.p);console.log(`${C.x4a} Key '${n}' stored`);return!0}catch(e){console.error(`${C.x4c} Set key '${n}':`,e.message);throw e}}async d(n){try{const d=await this.o.v(),l=d.collection(this.l),r=await l.deleteOne({name:n});if(r.deletedCount>0){this.h.d(n,this.p);console.log(`${C.x4a} Key '${n}' deleted`);return!0}return!1}catch(e){console.error(`${C.x4c} Delete key '${n}':`,e.message);throw e}}async l(){try{const d=await this.o.v(),l=d.collection(this.l),i=await l.find({}).toArray();return i.map(x=>({name:x.name,description:x.description||'',updatedAt:x.updatedAt}))}catch(e){console.error(`${C.x4c} List keys:`,e.message);throw e}}async p(){try{const i=await this.l(),d=await this.o.v(),l=d.collection(this.l);for(const x of i){const f=await l.findOne({name:x.name});if(f&&f.value)this.h.s(x.name,f.value,this.p)}console.log(`${C.x4a} Preloaded ${i.length} keys`);return i.length}catch(e){console.error(`${C.x4c} Preload keys:`,e.message);throw e}}}module.exports=K;